#include "mbed.h"

// Serial
Serial pc(USBTX, USBRX, 115200);

// LED
DigitalOut grn_led(LED2);
Thread heartbeat_thread(osPriorityLow, 256);
void heartbeat_fcn();

// Encoders
static int8_t enc_lookup_table[16] = {0, -1, 1, 0, 1, 0, 0, -1, -1, 0, 0, 1, 0, 1, -1, 0};
InterruptIn enc_0(PB_13);
InterruptIn enc_1(PB_14);
void enc_isr();
volatile int64_t enc_count = 0;

// Motors
// Motor 1
DigitalOut mot_dir = D3;
PwmOut mot_pwm = D4;

// Controllers
// gains bro
#define Kp .002f
#define Ki .00004f
#define Kd .05f
void controller_fcn();
Ticker controller_ticker;
int64_t motor_set = 0;

int main()
{
    mot_dir.write(0);
    mot_pwm.period_us(25); // 40 kHz
    mot_pwm.write(0.0f);
    controller_ticker.attach_us(&controller_fcn, 1000);

    // attach interrupts to all motors+pins on rise and fall
    enc_0.rise(&enc_isr);
    enc_0.fall(&enc_isr);
    enc_1.rise(&enc_isr);
    enc_1.fall(&enc_isr);

    // init with status LEDs off
    grn_led.write(0);

    heartbeat_thread.start(heartbeat_fcn); // start heartbeat after succesful inits
}

void controller_fcn()
{
    static int64_t err = 0;
    static int64_t last_err = 0;
    static float err_sum = 0;
    static float out = 0;

    // Apply control signal at start of fcn call
    mot_pwm.write(abs(out));

    err = motor_set - enc_count;

    out = Kp * err; // Proportional (this resets out to a new value, so it does not sum infinitely)

    // Integral
    if (err > 200 || err < -200 || err == 0)
    // anti-windup/saturation
    // only integrate error if near setpoint
    {
        err_sum = 0;
    }
    else
    {
        err_sum += Ki * err;
        out += err_sum;
    }

    out += Kd * (err - last_err); // Derivative
    last_err = err;               // Update last_error to be current err for next loop

    mot_dir.write(out / abs(out) == 1); // OPPOSITE TO M1
}

void enc_isr()
{
    static uint8_t enc_val = 0;
    enc_val = (enc_val << 2) | ((enc_0.read() << 1) | enc_1.read());
    enc_count += enc_lookup_table[enc_val & 0b1111];
}

void heartbeat_fcn()
{
    while (true)
    {
        grn_led.write(!grn_led);
        ThisThread::sleep_for(500);
    }
}
